%{
from SwiftIntTypes import all_integer_types
word_bits = int(CMAKE_SIZEOF_VOID_P) * 8
storageElementCounts = [2,4,8,16,32,64]
vectorElementCounts = storageElementCounts + [3]
}%

%for n in vectorElementCounts:
% storageN = 4 if n == 3 else n
@_fixed_layout
public struct Vector${n}<Scalar> : SIMDVector where Scalar: SIMDVectorizable {

  public var _storage: Scalar._Vector${storageN}

  public typealias Mask = SIMDMask<Vector${n}<Scalar._MaskElement>>

  @_transparent
  public var elementCount: Int {
    return ${n}
  }

  @_transparent
  public init() {
    _storage = Scalar._Vector${storageN}()
  }

  public subscript(index: Int) -> Scalar {
    @inlinable get {
      _precondition(indices.contains(index))
      return _storage[index]
    }
    @inlinable set {
      _precondition(indices.contains(index))
      _storage[index] = newValue
    }
  }

  @_transparent
  public init(${', '.join(['_ v' + str(i) + ': Scalar' for i in range(n)])}) {
    self.init()
% for i in range(n):
    self[${i}] = v${i}
% end
  }

% if n <= 4:
  @_transparent
  init(${', '.join([c + ': Scalar' for c in 'xyzw'[:n]])}) {
    self.init(${', '.join('xyzw'[:n])})
  }

%  for i in range(n):
  @_transparent
  var ${'xyzw'[i]}: Scalar {
    @_transparent get { return self[${i}]}
    @_transparent set { self[${i}] = newValue }
  }

%  end
% end
% if n >= 4:
  @_transparent
  init(lowHalf: Vector${n/2}<Scalar>, highHalf: Vector${n/2}<Scalar>) {
    self.init()
    self.lowHalf = lowHalf
    self.highHalf = highHalf
  }

%  for (half,indx) in [('low','i'), ('high',str(n/2)+'+i'), ('even','2*i'), ('odd','2*i+1')]:
  var ${half}Half: Vector${n/2}<Scalar> {
    @inlinable get {
      var result = Vector${n/2}<Scalar>()
      for i in result.indices { result[i] = self[${indx}] }
      return result
    }
    @inlinable set {
      for i in newValue.indices { self[${indx}] = newValue[i] }
    }
  }

%  end
% end
}

public extension Vector${n} where Scalar : FixedWidthInteger {
  @inlinable
  init<Other>(truncatingIfNeeded other: Vector${n}<Other>)
  where Other : FixedWidthInteger {
    self.init()
    for i in indices { self[i] = Scalar(truncatingIfNeeded: other[i]) }
  }

  @inlinable
  init<Other>(clamping other: Vector${n}<Other>)
  where Other : FixedWidthInteger {
    self.init()
    for i in indices { self[i] = Scalar(clamping: other[i]) }
  }
}

%end

%for self_type in all_integer_types(word_bits):
% Self = self_type.stdlib_name
% BuiltinName = self_type.builtin_name
% Mask = Self if self_type.is_signed else self_type.get_opposite_signedness().stdlib_name
extension ${Self} : SIMDVectorizable {

  public typealias _MaskElement = ${Mask}

% for n in storageElementCounts:
  @_fixed_layout public struct _Vector${n} : SIMDVectorStorage {

    public var _value: Builtin.Vec${n}x${BuiltinName}

    @_transparent
    public var elementCount: Int {
      return ${n}
    }

    @_transparent
    public init() {
      _value = Builtin.zeroInitializer()
    }

    public subscript(index: Int) -> ${Self} {
      @_transparent
      get {
        return ${Self}(Builtin.extractelement_Vec${n}x${BuiltinName}_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent
      set {
        _value = Builtin.insertelement_Vec${n}x${BuiltinName}_${BuiltinName}_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
  }

% end
}

%end

%for (Self, bits) in [('Float',32), ('Double',64)]:
extension ${Self} : SIMDVectorizable {

  public typealias _MaskElement = Int${bits}

% for n in storageElementCounts:
  @_fixed_layout public struct _Vector${n} : SIMDVectorStorage {

    public var _value: Builtin.Vec${n}xFPIEEE${bits}

    @_transparent
    public var elementCount: Int {
      return ${n}
    }

    @_transparent
    public init() {
      _value = Builtin.zeroInitializer()
    }

    public subscript(index: Int) -> ${Self} {
      @_transparent
      get {
        return ${Self}(Builtin.extractelement_Vec${n}xFPIEEE${bits}_Int32(
          _value, Int32(truncatingIfNeeded: index)._value
        ))
      }
      @_transparent
      set {
        _value = Builtin.insertelement_Vec${n}xFPIEEE${bits}_FPIEEE${bits}_Int32(
          _value, newValue._value, Int32(truncatingIfNeeded: index)._value
        )
      }
    }
  }

% end
}

%end
